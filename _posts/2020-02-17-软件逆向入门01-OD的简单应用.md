---
layout: post
title:  "软件逆向入门01"
subtitle: 'OD的简单应用'
date:   2020-02-17 18:00:00
tags: 逆向 工具
description: '逆向 工具'
color: 'rgb(135,206,250)'
cover: 'https://a111-1255560786.cos.ap-nanjing.myqcloud.com/9-14-2.jpg'
---


## 0x01 前言

软件逆向工程所涉及知识面较为广泛，本系列文章注重从动手出发，在过程中对知识点查漏补缺，适合各类对软件逆向有兴趣的朋友（这就是传说中的野路子HHH）。如果你有充分的时间去研究学习，那么还是建议从基础一步一步走下去。如果文中存在错误请及时指出，以免误导新人。



## 0x02 OD介绍

OD全称OllyDbg ，是一种具有可视化界面的 32 位汇编-分析调试器。和IDA不同之处在于可以动态调试软件功能，可以有效的去分析程序构成。

以下软件讲解均以吾爱破解中的OD进行讲解。[软件下载](https://down.52pojie.cn/Tools/Debuggers/%E5%90%BE%E7%88%B1%E7%A0%B4%E8%A7%A3%E4%B8%93%E7%94%A8%E7%89%88Ollydbg.rar)

打开程序主页面我们可以看到以下内容

![image-20200914184101048](https://a111-1255560786.cos.ap-nanjing.myqcloud.com/image-20200914184101048.png)

首先介绍一下软件主页面的4个窗口：

反汇编窗口：地址即为程序的内存地址,hex即为hex数据，反汇编就是程序的汇编代码，注释即为od分析出来的，双击即可编辑，信息窗口能对操作进行更加详细的查看

寄存器窗口：寄存器是CPU内部用来存放数据的一些小型存储区域，用来暂时存放参与运算的数据和运算结果

堆栈窗口：主要存放线程的临时数据,可以用于动态调试

数据窗口：主要的即为程序或者内存的数据

 

如果在没有一些基础知识的情况下，看到这个页面往往是很懵的，不知道什么是什么。这里我们来补充一下一些基础知识。

### 2.1 汇编语言是什么？

汇编语言（assembly language）是一种用于电子计算机、微处理器、微控制器或其他可编程器件的低级语言，亦称为符号语言。在汇编语言中，用助记符代替机器指令的操作码，用地址符号或标号代替指令或操作数的地址。在不同的设备中，汇编语言对应着不同的机器语言指令集，通过汇编过程转换成机器指令。特定的汇编语言和特定的机器语言指令集是一一对应的，不同平台之间不可直接移植。 --摘自百度百科

如果你精通汇编，可以大大的提升软件逆向能力。口算MD5都不在话下。

不过这里呢，我们就简单介绍一些常见的汇编指令。在平时的练习中，可以边查边看，虽然这样速度慢了一点，有时候还会疯掉，不过问题都不大。

```
汇编中常见指令

cmp a,b 比较a与b 

mov a,b 把b的值送给a 

ret 返回主程序

nop 无作用

call 调用子程序

je 或jz 若相等则跳(机器码74 或0F84) 

jne或jnz 若不相等则跳(机器码75或0F85) 

jmp 无条件跳(机器码EB) 

jb 若小于则跳

ja 无符-若大于则跳 

jg 有符-若大于则跳 

jge 若大于等于则跳

jl 若小于则跳

jle 若小于等于则跳

pop 出栈

push 压栈
```

### 2.2 堆栈是什么？

堆栈是一个特定的存储区或寄存器，它的一端是固定的，另一端是浮动的  。对这个存储区存入的数据，是一种特殊的数据结构。所有的数据存入或取出，只能在浮动的一端（称栈顶）进行，严格按照“先进后出”的原则存取，位于其中间的元素，必须在其栈上部（后进栈者）诸元素逐个移出后才能取出。在内存储器（随机存储器）中开辟一个区域作为堆栈，叫软件堆栈；用寄存器构成的堆栈，叫硬件堆栈。

单片机应用中，堆栈是个特殊存储区，堆栈属于RAM空间的一部分，堆栈用于函数调用、中断切换时保存和恢复现场数据。堆栈中的物体具有一个特性：第一个放入堆栈中的物体总是被最后拿出来， 这个特性通常称为先进后出 (FILO—First-In/Last-Out)。 堆栈中定义了一些操作， 两个最重要的是PUSH和POP。 PUSH（入栈）操作：堆栈指针（SP）加1，然后在堆栈的顶部加入一 个元素。POP（出栈）操作相反，出栈则先将SP所指示的内部ram单元中内容送入直接地址寻址的单元中（目的位置），然后再将堆栈指针（SP）减1。这两种操作实现了数据项的插入和删除。  --摘自百度百科

这里呢我们平时在看OD中的堆栈窗口，主要看的就是堆栈中数据的调用和指针信息。

### 2.3寄存器是什么？

寄存器的功能是存储二进制代码，它是由具有存储功能的触发器组合起来构成的。一个触发器可以存储1位二进制代码，故存放n位二进制代码的寄存器，需用n个触发器来构成。 

按照功能的不同，可将寄存器分为基本寄存器和移位寄存器两大类。基本寄存器只能并行送入数据，也只能并行输出。移位寄存器中的数据可以在移位脉冲作用下依次逐位右移或左移，数据既可以并行输入、并行输出，也可以串行输入、串行输出，还可以并行输入、串行输出，或串行输入、并行输出，十分灵活，用途也很广。 --摘自百度百科

 

我们需要记住这三个寄存器

BP：基址指针寄存器。  存放一个指针，该指针指向栈底。

SP：堆栈指针寄存器。 存放一个指针，该指针指向栈顶。

IP：用来存放将要执行的下一条指令在现行代码段中的偏移地址。程序运行中，它由BIU自动修改，使IP始终指向下一条将要执行的指令的地址，因此它是用来控制指令序列的执行流程的，是一个重要的寄存器。

平时在学习的过程中可以观察这两个寄存器的变化，加深对堆栈的理解。



## 0x03 OD的使用

### 3.1 OD调试进程的方法有三种

  （1）方法一：直接调试。使用快捷键F3（或OD菜单[文件] – [打开]）选择欲调试的可执行程序，等OD载入后即为进程。这种方法用的最多，也是调试信息最全面的。

  （2）方法二：附加调试。使用OD菜单[文件] – [附加]，可以附加到进程列表中正在运行的进程。这种方法属于半路劫持，调试进程的时候比较危险，特别是系统进程。关闭OD的同时，这个进程也会被关闭。在调试中不要挂接重要的系统进程，否则可能会导致整个操作系统的崩溃。

  （3）方法三：即时调试。打开OD菜单中选择[选项] – [实时调试设置]，并在弹出的对话框中单击按钮[设置OllyDbg为即时调试器]。设置完成后，如果某个应用程序发生了非法操作（缓冲区溢出、非法指令等），操作系统将提示是否用 OD调试这个程序。操作系统会启动OD并直接停在发生异常的地方。

### 3.2 OD中的快捷键

```
 F2   //下断点
 F3   //加载一个可执行程序
 F4   //程序执行到光标处
 F5   //缩小，还原当前窗口
 F7   //单步步入
 F8   //单步步过
 F9   //直接运行程序，遇到断点处，程序会暂停
 Ctrl+F2   //重新运行程序到起始处，用于重新调试程序
 Ctrl+F9   //执行到函数的返回处，用于跳出函数
 Alt+F9   //执行到用户代码处，用于快速跳出系统函数
 Ctrl+G   //输入十六进制地址，快速定位到该地址处
```

### 3.3 OD中的断点

INT3断点

  通过快捷键F2即可在相应代码处设置INT3型断点。INT3断点将代码的第一个字节，用一个特殊命令INT3（调试器陷阱标志，十六进制表示为0xCC）来替代。可以在反汇编窗口中选中要设断点的指令行并通过快捷键F2就可以设定一个此类型的断点。也可以在快捷菜单中设置其他快捷键。当再次按下F2键时，断点将被删除。注意，程序将在设断指令被执行之前中断下来。

  INT3断点的设置数量是没有限制的。当关闭被调试程序或者调试器的时候，OD将自动把这些断点保存到硬盘中，最好不要在数据段或者指令的中间设置这种断点，如果在代码段以外设置断点，OD将会给出一个警告。可以在安全选项［Security options］中永远关闭这个提示，在某些情况下调试器会插入自带的临时INT3断点。

 

内存断点：

  OD每一时刻只允许有一个内存断点。可以在反汇编窗口、CPU窗口、数据窗口中选择一部分内存，然后使用快捷菜单设置内存断点。如果有以前的内存断点，将被自动删除。可以有两个选择：在内存访问（读，写，执行）时中断，或内存写入时中断。设置此类断点时，OD将会改变所选部分的内存块的属性。在与80x86兼容的处理器上将会有4096字节的内存被分配并保护起来。即使仅仅选择了一个字节，OD也会将整个内存块都保护起来。这将会引起大量的错误警告，请小心使用此类断点。某些系统函数（特别是在Windows95/98下）在访问受保护的内存时不但不会产生调试事件反而会造成被调试程序的崩溃。

 

硬件断点

 （仅在Windows ME，NT或2000下可用）在80x86兼容的处理器上，OD允许设置4个硬件断点。和内存断点不同，硬件断点并不会降低执行速度，但是最多只能覆盖四个字节。在单步执行或者跟踪代码时，OD能够使用硬断点代替INT3断点。

## 0x04 拿到一个待破解的程序我们应该做什么？

首先分析程序文件构成，看看是PE文件还是ELF文件，32位还是64位，加壳还是没加壳等。

其次打开软件看其功能，需要怎么去破解。

然后就是静态分析或者动态分析进行破解。

嗯，相当简单(*^▽^\*)

## 0x05 一个简单的实例

```c
程序源码
#include <stdio.h>
#include <stdlib.h>

int main()
{
    int num;
 
    printf("Please input password: ");
    scanf("%d",&num);
 
    (num==12343234)?printf("Hello Word！ \n"):printf("Passwd Error. \n"); //叹号是中文
    system("pause");      //暂停函数，请按任意键继续...
    return 0;
}
```

这是一个很简单一个C程序，程序实现了输入并认证然后输入，模拟平时软件需要认证的情况。

我们先来运行一下看看是个什么东西。

![image-20200914185107685](https://a111-1255560786.cos.ap-nanjing.myqcloud.com/image-20200914185107685.png)

就是输入密码进行判断，密码正确输出一个值。

这里我们直接使用OD打开这个程序。

![image-20200914185300077](https://a111-1255560786.cos.ap-nanjing.myqcloud.com/image-20200914185300077.png)

程序载入后会自己运行。

我们先F9或者点击下图中的红框部分

![image-20200914185332592](https://a111-1255560786.cos.ap-nanjing.myqcloud.com/image-20200914185332592.png)

可以看到右边程序到达了让输入密码的地方并暂停了下来。这个时继续执行就执行不下去了。

可以自己输入跟踪看看程序逻辑。而后我们查看字符串定位。

![image-20200914185414031](https://a111-1255560786.cos.ap-nanjing.myqcloud.com/image-20200914185414031.png)

![image-20200914185427527](https://a111-1255560786.cos.ap-nanjing.myqcloud.com/image-20200914185427527.png)

跟踪过去，分析后发现再其地址00401447处存在判断。判断后就会进行跳转到00401457进而输出passwd error。

![image-20200914185454529](https://a111-1255560786.cos.ap-nanjing.myqcloud.com/image-20200914185454529.png)

我们把这里修改为我们想让他跳转的地址，双击进行编辑。

![image-20200914190220148](https://a111-1255560786.cos.ap-nanjing.myqcloud.com/image-20200914190220148.png)

然后复制到可执行文件

![image-20200914190247470](https://a111-1255560786.cos.ap-nanjing.myqcloud.com/image-20200914190247470.png)

之后右键另存为。我这里保存为ppp1.exe。

我们来看下最后效果，可以看到随意输入即可绕过密码验证。

![image-20200914190425296](https://a111-1255560786.cos.ap-nanjing.myqcloud.com/image-20200914190425296.png)